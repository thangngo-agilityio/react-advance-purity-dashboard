import{r as O,g as F,d as $}from"./index-Dl0dYXn5.js";var R={exports:{}},P={},j={exports:{}},H={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var E=O;function z(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var U=typeof Object.is=="function"?Object.is:z,T=E.useState,J=E.useEffect,L=E.useLayoutEffect,q=E.useDebugValue;function A(t,e){var n=e(),o=T({inst:{value:n,getSnapshot:e}}),s=o[0].inst,r=o[1];return L(function(){s.value=n,s.getSnapshot=e,b(s)&&r({inst:s})},[t,n,e]),J(function(){return b(s)&&r({inst:s}),t(function(){b(s)&&r({inst:s})})},[t]),q(n),n}function b(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!U(t,n)}catch{return!0}}function W(t,e){return e()}var k=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?W:A;H.useSyncExternalStore=E.useSyncExternalStore!==void 0?E.useSyncExternalStore:k;j.exports=H;var B=j.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _=O,C=B;function M(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var G=typeof Object.is=="function"?Object.is:M,Z=C.useSyncExternalStore,K=_.useRef,Q=_.useEffect,V=_.useMemo,X=_.useDebugValue;P.useSyncExternalStoreWithSelector=function(t,e,n,o,s){var r=K(null);if(r.current===null){var d={hasValue:!1,value:null};r.current=d}else d=r.current;r=V(function(){function S(l){if(!c){if(c=!0,h=l,l=o(l),s!==void 0&&d.hasValue){var v=d.value;if(s(v,l))return g=v}return g=l}if(v=g,G(h,l))return v;var u=o(l);return s!==void 0&&s(v,u)?v:(h=l,g=u)}var c=!1,h,g,p=n===void 0?null:n;return[function(){return S(e())},p===null?void 0:function(){return S(p())}]},[e,n,o,s]);var f=Z(t,r[0],r[1]);return Q(function(){d.hasValue=!0,d.value=f},[f]),X(f),f};R.exports=P;var Y=R.exports;const tt=F(Y);var et={VITE_API_ENDPOINT:"https://api.airtable.com/v0/app329Z57MGz3zPDB",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const x=t=>{let e;const n=new Set,o=(h,g)=>{const p=typeof h=="function"?h(e):h;if(!Object.is(p,e)){const l=e;e=g??(typeof p!="object"||p===null)?p:Object.assign({},e,p),n.forEach(v=>v(e,l))}},s=()=>e,S={setState:o,getState:s,getInitialState:()=>c,subscribe:h=>(n.add(h),()=>n.delete(h)),destroy:()=>{(et?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},c=e=t(o,s,S);return S},rt=t=>t?x(t):x,{useDebugValue:nt}=$,{useSyncExternalStoreWithSelector:ot}=tt,st=t=>t;function at(t,e=st,n){const o=ot(t.subscribe,t.getState,t.getServerState||t.getInitialState,e,n);return nt(o),o}const D=(t,e)=>{const n=rt(t),o=(s,r=e)=>at(n,s,r);return Object.assign(o,n),o},it=(t,e)=>t?D(t,e):D;var ut={VITE_API_ENDPOINT:"https://api.airtable.com/v0/app329Z57MGz3zPDB",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};function N(t,e){let n;try{n=t()}catch{return}return{getItem:s=>{var r;const d=S=>S===null?null:JSON.parse(S,void 0),f=(r=n.getItem(s))!=null?r:null;return f instanceof Promise?f.then(d):d(f)},setItem:(s,r)=>n.setItem(s,JSON.stringify(r,void 0)),removeItem:s=>n.removeItem(s)}}const I=t=>e=>{try{const n=t(e);return n instanceof Promise?n:{then(o){return I(o)(n)},catch(o){return this}}}catch(n){return{then(o){return this},catch(o){return I(o)(n)}}}},ct=(t,e)=>(n,o,s)=>{let r={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,m)=>({...m,...i}),...e},d=!1;const f=new Set,S=new Set;let c;try{c=r.getStorage()}catch{}if(!c)return t((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),n(...i)},o,s);const h=I(r.serialize),g=()=>{const i=r.partialize({...o()});let m;const a=h({state:i,version:r.version}).then(y=>c.setItem(r.name,y)).catch(y=>{m=y});if(m)throw m;return a},p=s.setState;s.setState=(i,m)=>{p(i,m),g()};const l=t((...i)=>{n(...i),g()},o,s);let v;const u=()=>{var i;if(!c)return;d=!1,f.forEach(a=>a(o()));const m=((i=r.onRehydrateStorage)==null?void 0:i.call(r,o()))||void 0;return I(c.getItem.bind(c))(r.name).then(a=>{if(a)return r.deserialize(a)}).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==r.version){if(r.migrate)return r.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var y;return v=r.merge(a,(y=o())!=null?y:l),n(v,!0),g()}).then(()=>{m==null||m(v,void 0),d=!0,S.forEach(a=>a(v))}).catch(a=>{m==null||m(void 0,a)})};return s.persist={setOptions:i=>{r={...r,...i},i.getStorage&&(c=i.getStorage())},clearStorage:()=>{c==null||c.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>u(),hasHydrated:()=>d,onHydrate:i=>(f.add(i),()=>{f.delete(i)}),onFinishHydration:i=>(S.add(i),()=>{S.delete(i)})},u(),v||l},lt=(t,e)=>(n,o,s)=>{let r={storage:N(()=>localStorage),partialize:u=>u,version:0,merge:(u,i)=>({...i,...u}),...e},d=!1;const f=new Set,S=new Set;let c=r.storage;if(!c)return t((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),n(...u)},o,s);const h=()=>{const u=r.partialize({...o()});return c.setItem(r.name,{state:u,version:r.version})},g=s.setState;s.setState=(u,i)=>{g(u,i),h()};const p=t((...u)=>{n(...u),h()},o,s);s.getInitialState=()=>p;let l;const v=()=>{var u,i;if(!c)return;d=!1,f.forEach(a=>{var y;return a((y=o())!=null?y:p)});const m=((i=r.onRehydrateStorage)==null?void 0:i.call(r,(u=o())!=null?u:p))||void 0;return I(c.getItem.bind(c))(r.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==r.version){if(r.migrate)return r.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var y;return l=r.merge(a,(y=o())!=null?y:p),n(l,!0),h()}).then(()=>{m==null||m(l,void 0),l=o(),d=!0,S.forEach(a=>a(l))}).catch(a=>{m==null||m(void 0,a)})};return s.persist={setOptions:u=>{r={...r,...u},u.storage&&(c=u.storage)},clearStorage:()=>{c==null||c.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>v(),hasHydrated:()=>d,onHydrate:u=>(f.add(u),()=>{f.delete(u)}),onFinishHydration:u=>(S.add(u),()=>{S.delete(u)})},r.skipHydration||v(),l||p},dt=(t,e)=>"getStorage"in e||"serialize"in e||"deserialize"in e?((ut?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),ct(t,e)):lt(t,e),ft=dt,w={user:null},vt=t=>{const e=localStorage.getItem(t),n=JSON.stringify(w);return e||n},mt=(t,e)=>{const{state:{user:n}}=JSON.parse(e);return!!n&&!!Object.keys(n).length?localStorage.setItem(t,e):localStorage.removeItem(t)},St=t=>localStorage.removeItem(t),ht=()=>({getItem:vt,setItem:mt,removeItem:St}),pt=it(ft(t=>({...w,setUser:e=>t(e),removeUser:()=>{t(w),pt.persist.clearStorage()}}),{name:"auth",storage:N(ht)}));export{pt as a};
